<!DOCTYPE html>
<html lang="pl">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>WH40k Data-Slate — Infoczytnik</title>

<!-- Google Fonts (fallback do Calibri/Arial jeśli brak internetu) -->
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Cinzel:wght@400;700&family=Rajdhani:wght@400;600&family=Black+Ops+One&family=Staatliches&family=Orbitron:wght@400;700&family=Questrial&family=Russo+One&display=swap" rel="stylesheet">

<style>
  :root{
    --accent:#00ff66;
    --font: Calibri, Arial, sans-serif;

    /* Bezpieczne marginesy tekstu (z zapasem, żeby nie nachodzić na ozdoby) */
    --screen-top: 14%;
    --screen-right: 14%;
    --screen-bottom: 22%;
    --screen-left: 18%;

    /* Efekt "transmission" */
    --tx-bright-peak: 3.00; /* szczyt jasności (puls) */
    --tx-jitter: 15px;      /* amplituda drgań */
    --tx-duration: 3s;      /* czas pulsu */
  }

  *{box-sizing:border-box}
  html,body{height:100%; margin:0; background:#000; overflow:hidden;}
  body{color:var(--accent); font-family:var(--font);}

  .wrap{
    width:100vw; height:100vh;
    display:flex;
    align-items:center;
    justify-content:center;
    background:#000;
    overflow:hidden;
  }

  .panel{
    position:relative;
    overflow:hidden;
    background:#000;
  }

  .layout-img{
    position:absolute;
    inset:0;
    width:100%;
    height:100%;
    object-fit:contain;
    object-position:center;
    user-select:none;
    -webkit-user-drag:none;
    pointer-events:none;
  }

  /* CRT / Scanlines overlay */
  .crt::before{
    content:"";
    position:absolute;
    inset:0;
    pointer-events:none;
    background:
      repeating-linear-gradient(
        to bottom,
        rgba(255,255,255,.06) 0px,
        rgba(255,255,255,.06) 1px,
        rgba(0,0,0,0) 3px,
        rgba(0,0,0,0) 7px
      );
    opacity:.28;
    mix-blend-mode: overlay;
    animation: scanMove 12s linear infinite;
  }
  .crt::after{
    content:"";
    position:absolute;
    inset:-2%;
    pointer-events:none;
    background:
      radial-gradient(closest-side, rgba(0,0,0,0) 60%, rgba(0,0,0,.70) 100%),
      rgba(255,255,255,.04);
    opacity:.65;
    animation: flickerBg 9s infinite;
  }
  @keyframes scanMove { 0%{transform:translateY(0)} 100%{transform:translateY(20px)} }
  @keyframes flickerBg {
    0%,92%,100%{opacity:.65}
    93%{opacity:.55}
    95%{opacity:.72}
    97%{opacity:.60}
  }

  /* Bezpieczne pole na tekst – scroll tylko tutaj */
  .screen{
    position:absolute;
    top:var(--screen-top);
    right:var(--screen-right);
    bottom:var(--screen-bottom);
    left:var(--screen-left);

    overflow:auto;
    -webkit-overflow-scrolling:touch;
    padding: clamp(14px, 2.4vw, 24px);

    /* screen zawsze istnieje; "czyszczenie" usuwa treść, nie UI */
    display:block;

    text-shadow: 0 2px 6px rgba(0,0,0,.70);
  }

  /* ====== TRANSMISSION EFFECT (puls + jitter) ====== */
  @keyframes txPulse {
    0%   { filter: brightness(1.00); opacity: 1; }
    10%  { filter: brightness(var(--tx-bright-peak)); opacity: 1; }
    22%  { filter: brightness(.60); opacity: .85; }
    38%  { filter: brightness(calc(var(--tx-bright-peak) * 0.85)); opacity: 1; }
    55%  { filter: brightness(.78); opacity: .90; }
    75%  { filter: brightness(calc(var(--tx-bright-peak) * 0.55)); opacity: 1; }
    100% { filter: brightness(1.00); opacity: 1; }
  }

  @keyframes txJitter {
    0%   { transform: translate(0,0); }
    10%  { transform: translate(calc(var(--tx-jitter) * 0.55), calc(var(--tx-jitter) * -0.40)); }
    20%  { transform: translate(calc(var(--tx-jitter) * -0.65), calc(var(--tx-jitter) * 0.45)); }
    30%  { transform: translate(calc(var(--tx-jitter) * 0.80), 0px); }
    40%  { transform: translate(calc(var(--tx-jitter) * -0.95), calc(var(--tx-jitter) * -0.30)); }
    50%  { transform: translate(calc(var(--tx-jitter) * 0.40), calc(var(--tx-jitter) * 0.70)); }
    60%  { transform: translate(calc(var(--tx-jitter) * -0.55), calc(var(--tx-jitter) * -0.80)); }
    70%  { transform: translate(calc(var(--tx-jitter) * 0.95), calc(var(--tx-jitter) * 0.40)); }
    80%  { transform: translate(calc(var(--tx-jitter) * -0.80), calc(var(--tx-jitter) * 0.10)); }
    90%  { transform: translate(calc(var(--tx-jitter) * 0.25), calc(var(--tx-jitter) * -0.65)); }
    100% { transform: translate(0,0); }
  }

  .tx-on{
    animation: txPulse var(--tx-duration) ease-out 1;
  }
  .tx-on .msg,
  .tx-on .prefixRow,
  .tx-on .suffixRow{
    animation: txJitter .6s linear 5; /* 5*0.6s ~ 3s */
  }

  /* Prefix + logo po PRAWEJ */
  .prefixRow{
    display:flex;
    align-items:flex-start;
    justify-content:space-between;
    gap: 12px;
  }

  .prefix{
    flex: 1 1 auto;
    color: rgba(255,255,255,.88);
    font-size: clamp(12px, 2.0vw, 16px);
    letter-spacing: 1.5px;
    margin: 0 0 10px 0;
    white-space: pre-wrap;
  }

  .logoBox{
    flex: 0 0 auto;
    width: 54px;
    height: 54px;
    display:flex;
    align-items:center;
    justify-content:center;
  }

  .logo{
    width:100%;
    height:100%;
    object-fit:contain;
    object-position:center;
    opacity:.95;
    filter: drop-shadow(0 2px 6px rgba(0,0,0,.7));
    pointer-events:none;
    user-select:none;
    display:none; /* pokażemy tylko dla wybranych frakcji */
  }

  .msg{
    position:relative;
    font-size: clamp(18px, 3.4vw, 32px);
    line-height: 1.35;
    white-space: pre-wrap;
    word-break: break-word;
    color: var(--accent);
    text-shadow: 0 0 18px rgba(0,255,120,.18), 0 2px 6px rgba(0,0,0,.70);
  }

  .suffixRow{
    display:flex;
    align-items:flex-start;
  }

  .suffix{
    color: rgba(255,255,255,.86);
    font-size: clamp(12px, 2.0vw, 16px);
    letter-spacing: 1.5px;
    margin: 12px 0 0 0;
    white-space: pre-wrap;
  }

  /* Audio unlock overlay */
  .unlock{
    position:fixed;
    inset:0;
    display:flex;
    align-items:center;
    justify-content:center;
    background:rgba(0,0,0,.88);
    color:rgba(255,255,255,.9);
    font-family: Calibri, Arial, sans-serif;
    z-index:9999;
    text-align:center;
    cursor:pointer;
    padding:24px;
  }
  .unlock .box{
    border:1px solid rgba(255,255,255,.18);
    border-radius:16px;
    padding:18px 16px;
    max-width:560px;
    background:rgba(0,0,0,.35);
  }
  .unlock .title{font-size:18px; margin-bottom:8px;}
  .unlock .hint{font-size:13px; opacity:.78; line-height:1.35;}
  .unlock .tiny{margin-top:10px; font-size:12px; opacity:.6;}

  /* Debug overlay */
  #debug{
    position:fixed;
    left:8px; bottom:8px;
    font-family: Consolas, "Courier New", monospace;
    font-size:11px;
    color:rgba(255,255,255,.85);
    background:rgba(0,0,0,.55);
    border:1px solid rgba(255,255,255,.16);
    border-radius:12px;
    padding:10px;
    max-width:min(92vw,640px);
    white-space:pre-wrap;
    z-index:10000;
    display:none;
    max-height: 40vh;
    overflow:auto;
  }
</style>
</head>

<body>
  <div class="unlock" id="unlock">
    <div class="box">
      <div class="title">Kliknij raz, aby odblokować dźwięk</div>
      <div class="hint">
        Chrome blokuje audio, dopóki w tej karcie nie wykonasz akcji.
        To jednorazowe (po odświeżeniu trzeba kliknąć ponownie).
      </div>
      <div class="tiny">(Kliknij gdziekolwiek)</div>
    </div>
  </div>

  <div class="wrap">
    <div class="panel crt" id="panel">
      <img class="layout-img" id="layoutImg" alt="layout" />
      <div class="screen" id="screen">
        <div class="prefixRow">
          <div class="prefix" id="prefixLine"></div>
          <div class="logoBox">
            <img class="logo" id="logo" alt="logo" />
          </div>
        </div>

        <div class="msg" id="msg"></div>

        <div class="suffixRow">
          <div class="suffix" id="suffixLine"></div>
        </div>
      </div>
    </div>
  </div>

  <div id="debug"></div>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-app.js";
  import { getFirestore, doc, onSnapshot } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-firestore.js";

  const firebaseConfig = {
    apiKey: "AIzaSyCVoWzXtO-vipsxnvZlFkcqcNgYYuH3osc",
    authDomain: "wh40k-data-slate.firebaseapp.com",
    projectId: "wh40k-data-slate",
    storageBucket: "wh40k-data-slate.firebasestorage.app",
    messagingSenderId: "382792444120",
    appId: "1:382792444120:web:9eb27e2ed29109ac838fad"
  };

  const app = initializeApp(firebaseConfig);
  const db  = getFirestore(app);

  // Cache-busting do zasobów na GitHub Pages.
  // Jeśli w przyszłości podmienisz pliki graficzne lub audio, zmień tę wartość,
  // żeby tablet na pewno pobrał nowe wersje (omija cache przeglądarki).
  const ASSET_VERSION = "2025-12-13-1";

  const DEFAULT_PING_URL = `assets/audio/global/Ping.mp3?v=${ASSET_VERSION}`;
  const DEFAULT_MSG_URL  = `assets/audio/global/Message.mp3?v=${ASSET_VERSION}`;

  const LAYOUT_BG = {
    inquisition: `assets/layouts/inquisition/DataSlate_Inq.png?v=${ASSET_VERSION}`,
    mechanicus:  `assets/layouts/mechanicus/DataSlate_04.png?v=${ASSET_VERSION}`,
    militarum:   `assets/layouts/militarum/DataSlate_04.png?v=${ASSET_VERSION}`,
    chaos_undivided: `assets/layouts/chaos_undivided/DataSlate_04.png?v=${ASSET_VERSION}`,
    khorne:      `assets/layouts/khorne/DataSlate_04.png?v=${ASSET_VERSION}`,
    nurgle:      `assets/layouts/nurgle/DataSlate_04.png?v=${ASSET_VERSION}`,
    tzeentch:    `assets/layouts/tzeentch/DataSlate_04.png?v=${ASSET_VERSION}`,
    slaanesh:    `assets/layouts/slaanesh/DataSlate_04.png?v=${ASSET_VERSION}`,
  };

  const LAYOUT_AR = {
    inquisition: 707/1023,
    default04:   1131/1600,
  };

  const SCREEN_INSETS = {
    inquisition: { top:"14%", right:"14%", bottom:"26%", left:"18%" },
    default04:   { top:"14%", right:"14%", bottom:"22%", left:"18%" },
  };

  const FONT_STACK = {
    mechanicus:      '"Share Tech Mono", Calibri, Arial, sans-serif',
    inquisition:     '"Cinzel", Calibri, Arial, sans-serif',
    militarum:       '"Rajdhani", Calibri, Arial, sans-serif',
    khorne:          '"Black Ops One", Calibri, Arial, sans-serif',
    nurgle:          '"Staatliches", Calibri, Arial, sans-serif',
    tzeentch:        '"Orbitron", Calibri, Arial, sans-serif',
    slaanesh:        '"Questrial", Calibri, Arial, sans-serif',
    chaos_undivided: '"Russo One", Calibri, Arial, sans-serif',
  };

  // Fillery (prefix/suffix) — używane gdy GM nie wyśle gotowego prefix/suffix,
  // tylko np. prefixIndex / suffixIndex.
  const FILLERS = {
    mechanicus: {
      prefixes:["++ INCOMING DATA FEED ++","++ SYSTEM ANALYSIS BEGIN ++","++ ENCRYPTION ONLINE ++","++ ENGAGE LITURGY ++","++ ARCHIVE ACCESS ++","++ LOGIS-CHANNEL ACTIVE ++","++ DATA LINK ESTABLISHED ++","++ SIGNAL LOCKED ++","++ CORE STABILIZED ++"],
      suffixes:["++ PRAISE THE OMNISSIAH ++","++ MACHINE SPIRIT CALMED ++","++ THE FLESH IS WEAK ++","++ SYSTEM CLEANSED ++","++ BINARY PRAYER SENT ++","++ OMNISSIAH GUIDE US ++","++ SERVITOR READY ++","++ RITUAL COMPLETE ++","++ PRAY TO THE CODE ++"]
    },
    inquisition: {
      prefixes:["++ INQUISITORIAL NOTICE ++","++ DATA INTERCEPTED ++","++ DECRYPTING ORDER ++","++ ORDER: SIGMA-9 ++","++ COGITATOR ACCESS ++","++ BY HIS WILL ++","++ CLASSIFIED MATERIAL ++","++ MIND CLEANSED ++","++ CODEX SECURED ++"],
      suffixes:["++ THE EMPEROR PROTECTS ++","++ AUTHORIZATION VERIFIED ++","++ PURGE COMPLETE ++","++ FAITH REMAINS ++","++ THOUGHT FOR THE DAY ++","++ HERESY PURGED ++","++ OATH UPHELD ++","++ FAITH IS ARMOR ++","++ EXAMINATION COMPLETE ++"]
    },
    militarum: {
      prefixes:["++ IMPERIAL SIGNAL ++","++ HIGH COMMAND ORDER ++","++ ORDERS INCOMING ++","++ TACTICAL FEED ++","++ REGIMENTAL DATA ++","++ COMMAND OVERRIDE ++","++ BATTLELINE UPLINK ++","++ ENGAGEMENT ACTIVE ++","++ OPERATIONAL BRIEF ++"],
      suffixes:["++ GLORY TO THE GUARD ++","++ VICTORY IS ASSURED ++","++ CADIA STANDS ++","++ DUTY FULFILLED ++","++ NO SACRIFICE TOO GREAT ++","++ PERIMETER SECURED ++","++ FOR THE EMPEROR ++","++ STATUS: GREEN ++","++ STRATEGIC DIRECTIVE ++"]
    },
    chaos_undivided: {
      prefixes:["++ WARP STIRRING ++","++ TRANSMISSION CORRUPTED ++","++ HERESY INBOUND ++","++ WARP SIGNATURE FOUND ++","++ SACRIFICE ACCEPTED ++","++ WARP ENERGY RISING ++","++ ORDER BREAKS ++","++ FLESH TURNS ++","++ ASCENSION IMMINENT ++"],
      suffixes:["++ GLORY TO CHAOS ++","++ DARK GODS SMILE ++","++ THE EYE OPENS ++","++ ASCEND AND BURN ++","++ ALL HAIL THE DARK GODS ++","++ REALSPACE BLEEDS ++","++ STARS ARE WRONG ++","++ VOID WITHIN ++","++ ETERNAL CHANGE ++"]
    }
  };

  // Logo: tylko 2 frakcje (Twoje ścieżki) — reszta pusta.
  const FACTION_LOGO = {
    inquisition: `assets/logos/inquisition/Inquisition.png?v=${ASSET_VERSION}`,
    mechanicus:  `assets/logos/mechanicus/Mechanicus.png?v=${ASSET_VERSION}`
  };

  const el = {
    unlock: document.getElementById("unlock"),
    panel: document.getElementById("panel"),
    layoutImg: document.getElementById("layoutImg"),
    screen: document.getElementById("screen"),
    prefixLine: document.getElementById("prefixLine"),
    suffixLine: document.getElementById("suffixLine"),
    msg: document.getElementById("msg"),
    logo: document.getElementById("logo"),
    debug: document.getElementById("debug"),
  };

  const debugOn = new URLSearchParams(location.search).get("debug") === "1";
  function dbg(s){
    console.log("[Infoczytnik]", s);
    if(!debugOn) return;
    el.debug.style.display = "block";
    el.debug.textContent = (el.debug.textContent + "\n" + s).trim();
    el.debug.scrollTop = el.debug.scrollHeight;
  }

  /* ============================================================
     FUNKCJA (WYŁĄCZONA CELOWO): automatyczne "tuningowanie" efektu
     różnie dla laptopa i tabletu.

     CO TO ROBIŁO?
     - Na mniejszych ekranach (typowo tablet) zwiększało brightness i jitter,
       bo animacje z filter:brightness() oraz przesunięcia w "CSS px" mogą
       wyglądać słabiej (DPR, inne renderowanie fontu/GPU).
     - Na większych ekranach (laptop) zostawiało wartości domyślne.

     DLACZEGO WYŁĄCZONE?
     - Użytkownik nie chce różnicować efektu między urządzeniami.
     - Ten kod pozostawiamy jako komentarz do dokumentacji i ewentualnego
       powrotu w przyszłości.

     (Jeśli kiedyś wrócimy do tematu ujednolicania – odkomentujemy i dostroimy.)
  ============================================================ */
  /*
  (function tuneEffectByScreen(){
    const minSide = Math.min(window.innerWidth, window.innerHeight);
    if(minSide <= 900){
      document.documentElement.style.setProperty("--tx-bright-peak", "3.20");
      document.documentElement.style.setProperty("--tx-jitter", "18px");
      document.documentElement.style.setProperty("--tx-duration", "3s");
      dbg("effect tuned for small screen (tablet boost)");
    }else{
      document.documentElement.style.setProperty("--tx-bright-peak", "3.00");
      document.documentElement.style.setProperty("--tx-jitter", "15px");
      document.documentElement.style.setProperty("--tx-duration", "3s");
      dbg("effect tuned for large screen (default)");
    }
  })();
  */

  let audioArmed = false;
  function armAudio(){
    if(audioArmed) return;
    audioArmed = true;
    el.unlock.style.display = "none";
    dbg("AUDIO ARMED");
  }
  el.unlock.addEventListener("click", armAudio);
  window.addEventListener("keydown", armAudio);

  async function playUrlOnce(url, kind){
    dbg(`play(${kind}): ${url}`);
    if(!audioArmed){ dbg("BLOCKED: audio not armed"); return; }
    try{
      const a = new Audio(url);
      a.addEventListener("error", () => dbg(`Audio element error (${kind})`));
      await a.play();
      dbg(`OK: playing (${kind})`);
    }catch(e){
      dbg(`ERROR play(${kind}): ${e?.message || e}`);
    }
  }

  function fitPanel(ar){
    const vw = window.innerWidth;
    const vh = window.innerHeight;

    let h = vh;
    let w = h * ar;

    if(w > vw){
      w = vw;
      h = w / ar;
    }

    el.panel.style.width  = Math.round(w) + "px";
    el.panel.style.height = Math.round(h) + "px";
  }

  function setInsets(preset){
    document.documentElement.style.setProperty("--screen-top", preset.top);
    document.documentElement.style.setProperty("--screen-right", preset.right);
    document.documentElement.style.setProperty("--screen-bottom", preset.bottom);
    document.documentElement.style.setProperty("--screen-left", preset.left);
  }

  let currentAr = LAYOUT_AR.default04;

  function setLogoForFaction(key){
    const src = FACTION_LOGO[key];
    if(!src){
      el.logo.removeAttribute("src");
      el.logo.style.display = "none";
      return;
    }
    el.logo.src = src;
    el.logo.style.display = "block";
  }

  function getFillerText(key, idx1based, kind){
    const cfg = FILLERS[key] || FILLERS.mechanicus;
    const arr = (kind === "prefix") ? cfg.prefixes : cfg.suffixes;
    const n = Number(idx1based);
    const i = (Number.isFinite(n) ? Math.floor(n) : 1) - 1;
    return arr[Math.max(0, Math.min(arr.length - 1, i))] || "";
  }

  function applyLayout(factionKey, color){
    const key = (factionKey && LAYOUT_BG[factionKey]) ? factionKey : "mechanicus";

    el.layoutImg.src = LAYOUT_BG[key] || LAYOUT_BG.mechanicus;

    document.documentElement.style.setProperty("--font", FONT_STACK[key] || 'Calibri, Arial, sans-serif');
    document.documentElement.style.setProperty("--accent", color || "#00ff66");

    if(key === "inquisition"){
      setInsets(SCREEN_INSETS.inquisition);
      currentAr = LAYOUT_AR.inquisition;
    }else{
      setInsets(SCREEN_INSETS.default04);
      currentAr = LAYOUT_AR.default04;
    }
    fitPanel(currentAr);

    setLogoForFaction(key);
  }

  // TRANSMISSION EFFECT
  let txTimer = null;
  function triggerTransmissionEffect(){
    el.screen.classList.remove("tx-on");
    void el.screen.offsetWidth; // reflow
    el.screen.classList.add("tx-on");
    if(txTimer) clearTimeout(txTimer);
    txTimer = setTimeout(()=> el.screen.classList.remove("tx-on"), 3000);
  }

  function showMessage(prefix, text, suffix){
    el.prefixLine.textContent = prefix || "";
    el.msg.textContent = text || "";
    el.suffixLine.textContent = suffix || "";
    el.screen.scrollTop = 0;
    triggerTransmissionEffect();
  }

  function clearMessageKeepLayout(){
    el.prefixLine.textContent = "";
    el.msg.textContent = "";
    el.suffixLine.textContent = "";
  }

  window.addEventListener("resize", () => fitPanel(currentAr));

  const currentRef = doc(getFirestore(app), "dataslate", "current");
  let lastNonce = null;

  onSnapshot(currentRef, (snap)=>{
    if(!snap.exists()){
      dbg("current doc missing");
      return;
    }
    const d = snap.data() || {};
    dbg(`current: type=${d.type} faction=${d.faction} nonce=${d.nonce}`);

    if(d.nonce && d.nonce === lastNonce) return;
    lastNonce = d.nonce || null;

    const faction = d.faction || "mechanicus";
    const color   = d.color || d.fontColor || "#00ff66";

    applyLayout(faction, color);

    if(d.type === "clear"){
      clearMessageKeepLayout();
      return;
    }

    if(d.type === "ping"){
      triggerTransmissionEffect();
      const pingUrl = (d.pingUrl ? `${d.pingUrl}` : DEFAULT_PING_URL);
      playUrlOnce(pingUrl, "ping");
      return;
    }

    if(d.type === "message"){
      // Obsługa różnych wersji GM:
      // - jeśli GM wysyła gotowe prefix/suffix: używamy ich
      // - jeśli GM wysyła prefixIndex/suffixIndex: budujemy z FILLERS
      const text = d.text ?? "";

      let prefix = d.prefix ?? d.prefixText ?? "";
      let suffix = d.suffix ?? d.suffixText ?? "";

      // jeśli brak tekstu prefix/suffix, spróbuj z indeksów
      if(!prefix && (d.prefixIndex || d.prefixIdx)){
        prefix = getFillerText(faction, d.prefixIndex || d.prefixIdx, "prefix");
      }
      if(!suffix && (d.suffixIndex || d.suffixIdx)){
        suffix = getFillerText(faction, d.suffixIndex || d.suffixIdx, "suffix");
      }

      // jeśli nadal puste (brak indeksów), a tekst istnieje, daj minimalne sensowne domyślne:
      if(!prefix && (text || "").trim()){
        prefix = getFillerText(faction, 1, "prefix");
      }
      if(!suffix && (text || "").trim()){
        suffix = getFillerText(faction, 1, "suffix");
      }

      if((text || "").trim().length === 0){
        clearMessageKeepLayout();
      }else{
        showMessage(prefix, text, suffix);
      }

      const msgUrl = (d.msgUrl || d.messageUrl) ? `${(d.msgUrl || d.messageUrl)}` : DEFAULT_MSG_URL;
      playUrlOnce(msgUrl, "message");
      return;
    }
  }, (err)=>{
    dbg("ERROR snapshot: " + (err?.message || err));
  });

  // Start
  applyLayout("mechanicus", "#00ff66");
  dbg("ready");
</script>
</body>
</html>
