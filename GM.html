<!DOCTYPE html>
<html lang="pl">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>WH40k Data-Slate ‚Äî GM</title>

<style>
  :root{
    --bg:#070707;
    --card:#0f0f0f;
    --card2:#111;
    --text:#e9e9e9;
    --muted:#a7a7a7;
    --line: rgba(255,255,255,.10);
    --accent:#00ff66;
  }
  *{box-sizing:border-box}
  html,body{height:100%; margin:0; background:var(--bg); color:var(--text); font-family: Calibri, Arial, sans-serif;}
  .wrap{max-width:1100px; margin:24px auto; padding:0 16px;}
  h1{margin:0 0 14px; font-size:34px; letter-spacing:.5px; color:#ffd27a}
  .grid{display:grid; grid-template-columns: 1fr 1fr; gap:16px;}
  @media (max-width: 980px){ .grid{grid-template-columns:1fr;} }

  .card{
    background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
    border:1px solid var(--line);
    border-radius:16px;
    padding:16px;
    box-shadow: 0 14px 40px rgba(0,0,0,.35);
  }
  .card h2{margin:0 0 10px; font-size:16px; color:#f2f2f2; opacity:.95}
  label{display:block; margin:10px 0 6px; color:var(--muted); font-size:13px}
  input[type="text"], input[type="number"], textarea, select{
    width:100%;
    background:rgba(0,0,0,.35);
    border:1px solid rgba(255,255,255,.14);
    color:var(--text);
    border-radius:12px;
    padding:12px 12px;
    outline:none;
  }
  textarea{min-height:180px; resize:vertical; line-height:1.35;}
  .row{display:flex; gap:12px; align-items:center; flex-wrap:wrap;}
  .row > *{flex:1 1 auto;}
  .btn{
    border:1px solid rgba(255,255,255,.16);
    background:rgba(0,0,0,.35);
    color:var(--text);
    border-radius:12px;
    padding:12px 14px;
    cursor:pointer;
    font-weight:600;
  }
  .btn:hover{border-color: rgba(255,255,255,.26);}
  .btn.primary{background:rgba(0,255,102,.10); border-color: rgba(0,255,102,.35);}
  .btn.danger{background:rgba(255,80,80,.10); border-color: rgba(255,80,80,.35);}
  .btn.small{padding:9px 10px; font-size:13px; font-weight:600;}
  .hint{margin-top:8px; color:var(--muted); font-size:12px; line-height:1.35}
  .divider{height:1px; background:rgba(255,255,255,.10); margin:14px 0;}
  .toggle{
    display:flex; align-items:center; gap:10px;
    color:var(--text);
    user-select:none;
  }
  .toggle input{width:18px; height:18px;}
  .kpi{font-size:12px; color:var(--muted)}
  .status{
    margin-top:12px;
    border:1px solid rgba(255,255,255,.10);
    background:rgba(0,0,0,.30);
    border-radius:14px;
    padding:10px 12px;
    color:#cfcfcf;
    font-size:12px;
    min-height: 40px;
    white-space: pre-wrap;
  }
  .quickcolors{display:flex; gap:10px; flex-wrap:wrap; margin-top:8px;}
  .chip{
    display:flex; align-items:center; gap:10px;
    padding:10px 12px;
    border-radius:999px;
    border:1px solid rgba(255,255,255,.16);
    background:rgba(0,0,0,.25);
    cursor:pointer;
    user-select:none;
  }
  .dot{width:14px; height:14px; border-radius:50%;}
  .chip:hover{border-color: rgba(255,255,255,.26);}

  /* ====== Losowo≈õƒá filler√≥w ‚Äì uk≈Çad z poprawionym wyr√≥wnaniem ====== */
  .fillerGrid{
    display:grid;
    grid-template-columns: 1fr 320px;
    gap:14px;
    align-items:start;
  }
  @media (max-width: 980px){
    .fillerGrid{grid-template-columns:1fr;}
  }
  .manualBox{
    border:1px solid rgba(255,255,255,.10);
    background:rgba(0,0,0,.22);
    border-radius:14px;
    padding:12px;
  }
  .manualGrid{
    display:grid;
    grid-template-columns: 1fr;
    gap:10px;
  }
  .inlineLabel{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:10px;
    color:var(--muted);
    font-size:13px;
  }
  .inlineLabel b{color:var(--text); font-weight:700}
  .inlineRow{
    display:flex;
    align-items:center;
    justify-content:flex-end;
    gap:10px;
  }
  .inlineRow input{
    width:120px;
    text-align:center;
  }

  .previewBox{
    border:1px dashed rgba(255,255,255,.14);
    border-radius:14px;
    padding:12px;
    background:rgba(0,0,0,.18);
    font-family: Consolas, "Courier New", monospace;
    color:#d6d6d6;
    white-space:pre-wrap;
    min-height: 70px;
  }

  .twoCols{
    display:grid;
    grid-template-columns: 1fr 1fr;
    gap:12px;
  }
  @media (max-width: 980px){
    .twoCols{grid-template-columns:1fr;}
  }
</style>
</head>

<body>
<div class="wrap">
  <h1>WH40k Data-Slate ‚Äî GM</h1>

  <div class="grid">

    <!-- LEFT: Layout + Style -->
    <div class="card">
      <h2>Ustawienia wyglƒÖdu (Infoczytnik)</h2>

      <label for="faction">Frakcja / layout</label>
      <select id="faction">
        <option value="mechanicus">Adeptus Mechanicus</option>
        <option value="inquisition">Inkwizycja</option>
        <option value="militarum">Astra Militarum</option>
        <option value="chaos_undivided">Chaos Undivided</option>
        <option value="khorne">Khorne</option>
        <option value="nurgle">Nurgle</option>
        <option value="tzeentch">Tzeentch</option>
        <option value="slaanesh">Slaanesh</option>
      </select>

      <div class="twoCols">
        <div>
          <label for="msgColor">Kolor tekstu (wiadomo≈õƒá)</label>
          <input id="msgColor" type="text" placeholder="#00ff66" value="#00ff66" />
          <div class="quickcolors" id="msgQuick">
            <div class="chip" data-color="#00ff66"><span class="dot" style="background:#00ff66"></span>Zielony</div>
            <div class="chip" data-color="#ff3b3b"><span class="dot" style="background:#ff3b3b"></span>Czerwony</div>
            <div class="chip" data-color="#d6b04a"><span class="dot" style="background:#d6b04a"></span>Z≈Çoty</div>
            <div class="chip" data-color="#ffffff"><span class="dot" style="background:#ffffff; border:1px solid rgba(0,0,0,.35)"></span>Bia≈Çy</div>
          </div>
        </div>

        <div>
          <label for="msgSize">Wielko≈õƒá fontu (wiadomo≈õƒá) ‚Äî px</label>
          <input id="msgSize" type="number" min="12" max="80" step="1" value="28" />
          <div class="hint">Wysy≈Çamy jako <code>msgFontSize</code> (np. <code>28px</code>). Je≈õli chcesz wr√≥ciƒá do automatycznego clamp ‚Äì powiedz.</div>
        </div>
      </div>

      <div class="divider"></div>

      <div class="twoCols">
        <div>
          <label for="psColor">Kolor Prefix + Suffix (wsp√≥lny)</label>
          <input id="psColor" type="text" placeholder="rgba(...) albo #ffffff" value="rgba(255,255,255,.88)" />
          <div class="quickcolors" id="psQuick">
            <div class="chip" data-color="#00ff66"><span class="dot" style="background:#00ff66"></span>Zielony</div>
            <div class="chip" data-color="#ff3b3b"><span class="dot" style="background:#ff3b3b"></span>Czerwony</div>
            <div class="chip" data-color="#d6b04a"><span class="dot" style="background:#d6b04a"></span>Z≈Çoty</div>
            <div class="chip" data-color="#ffffff"><span class="dot" style="background:#ffffff; border:1px solid rgba(0,0,0,.35)"></span>Bia≈Çy</div>
          </div>
          <div class="hint">Wysy≈Çamy do Infoczytnika jako <code>prefixColor</code> i <code>suffixColor</code> (to samo).</div>
        </div>

        <div>
          <label for="psSize">Wielko≈õƒá fontu Prefix + Suffix (wsp√≥lna) ‚Äî px</label>
          <input id="psSize" type="number" min="10" max="60" step="1" value="14" />
          <div class="hint">Wysy≈Çamy jako <code>prefixFontSize</code> i <code>suffixFontSize</code> (to samo).</div>
        </div>
      </div>

      <div class="divider"></div>

      <h2>Audio (Infoczytnik)</h2>
      <div class="twoCols">
        <div>
          <div class="toggle">
            <input type="checkbox" id="useDefaultPing" checked>
            <label for="useDefaultPing" style="margin:0; color:var(--text); font-size:14px;">Domy≈õlny Ping</label>
          </div>
          <label>Domy≈õlny Ping URL</label>
          <input id="defaultPingUrl" type="text" value="assets/audio/global/Ping.mp3" />
          <label>Ping URL dla wybranej frakcji (opcjonalnie)</label>
          <input id="factionPingUrl" type="text" placeholder="Zostaw puste, ≈ºeby u≈ºyƒá domy≈õlnego" disabled />
        </div>

        <div>
          <div class="toggle">
            <input type="checkbox" id="useDefaultMsg" checked>
            <label for="useDefaultMsg" style="margin:0; color:var(--text); font-size:14px;">Domy≈õlny Message</label>
          </div>
          <label>Domy≈õlny Message URL</label>
          <input id="defaultMsgUrl" type="text" value="assets/audio/global/Message.mp3" />
          <label>Message URL dla wybranej frakcji (opcjonalnie)</label>
          <input id="factionMsgUrl" type="text" placeholder="Zostaw puste, ≈ºeby u≈ºyƒá domy≈õlnego" disabled />
        </div>
      </div>

      <div class="row" style="margin-top:12px;">
        <button class="btn" id="saveAudio">Zapisz audio (defaults + ta frakcja)</button>
        <button class="btn" id="ping">Ping</button>
      </div>

      <div class="hint">
        ‚ÄûZapisz audio‚Äù zapisuje ustawienia do Firestore (dok. <code>dataslate/config</code>), ≈ºeby Infoczytnik m√≥g≈Ç ich u≈ºywaƒá.
        Ping odtwarza d≈∫wiƒôk ping w Infoczytniku.
      </div>

    </div>

    <!-- RIGHT: Message + Fillers -->
    <div class="card">
      <h2>Wiadomo≈õƒá</h2>

      <div class="fillerGrid">
        <div>
          <label class="toggle" style="margin-top:6px;">
            <input type="checkbox" id="randomFillers" checked>
            <span><b>Losuj automatycznie</b></span>
          </label>
          <div class="hint">Gdy wy≈ÇƒÖczone ‚Äì wybierasz osobno numer Prefix i Suffix (1..N zale≈ºnie od frakcji).</div>

          <label>PodglƒÖd Prefix</label>
          <div class="previewBox" id="previewPrefix">‚Äî</div>

          <label for="text">Tre≈õƒá wiadomo≈õci</label>
          <textarea id="text" placeholder="Wpisz tre≈õƒá..."></textarea>

          <div class="row" style="margin-top:10px;">
            <button class="btn small" id="clearText">Wyczy≈õƒá pole tekstowe</button>
          </div>

          <label>PodglƒÖd Suffix</label>
          <div class="previewBox" id="previewSuffix">‚Äî</div>
        </div>

        <!-- MANUAL BOX (po prawej) -->
        <div class="manualBox">
          <div class="manualGrid">
            <div class="inlineLabel">
              <span>Rƒôcznie:</span> <b>Prefix</b>
            </div>
            <div class="inlineRow">
              <input id="manualPrefix" type="number" min="1" step="1" value="1">
            </div>

            <!-- WYR√ìWNANIE: Suffix pod Prefix, po prawej -->
            <div class="inlineLabel">
              <span></span> <b>Suffix</b>
            </div>
            <div class="inlineRow">
              <input id="manualSuffix" type="number" min="1" step="1" value="1">
            </div>
          </div>
        </div>
      </div>

      <div class="divider"></div>

      <div class="row">
        <button class="btn primary" id="send">Wy≈õlij wiadomo≈õƒá</button>
        <button class="btn danger" id="clearScreen">Wyczy≈õƒá ekran</button>
      </div>

      <div class="status" id="status">Gotowe.</div>
      <div class="kpi" style="margin-top:8px;">
        Tip: dodaj <code>?debug=1</code> do URL Infoczytnika, je≈õli chcesz logi na ekranie.
      </div>
    </div>

  </div>
</div>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-app.js";
  import {
    getFirestore, doc, setDoc, updateDoc, serverTimestamp, getDoc
  } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-firestore.js";

  const firebaseConfig = {
    apiKey: "AIzaSyCVoWzXtO-vipsxnvZlFkcqcNgYYuH3osc",
    authDomain: "wh40k-data-slate.firebaseapp.com",
    projectId: "wh40k-data-slate",
    storageBucket: "wh40k-data-slate.firebasestorage.app",
    messagingSenderId: "382792444120",
    appId: "1:382792444120:web:9eb27e2ed29109ac838fad"
  };

  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);

  const currentRef = doc(db, "dataslate", "current");
  const configRef  = doc(db, "dataslate", "config");

  // ===== Fillery (do podglƒÖdu i wysy≈Çki indeks√≥w) =====
  const FILLERS = {
    mechanicus: {
      prefixes:["++ INCOMING DATA FEED ++","++ SYSTEM ANALYSIS BEGIN ++","++ ENCRYPTION ONLINE ++","++ ENGAGE LITURGY ++","++ ARCHIVE ACCESS ++","++ LOGIS-CHANNEL ACTIVE ++","++ DATA LINK ESTABLISHED ++","++ SIGNAL LOCKED ++","++ CORE STABILIZED ++"],
      suffixes:["++ PRAISE THE OMNISSIAH ++","++ MACHINE SPIRIT CALMED ++","++ THE FLESH IS WEAK ++","++ SYSTEM CLEANSED ++","++ BINARY PRAYER SENT ++","++ OMNISSIAH GUIDE US ++","++ SERVITOR READY ++","++ RITUAL COMPLETE ++","++ PRAY TO THE CODE ++"]
    },
    inquisition: {
      prefixes:["++ INQUISITORIAL NOTICE ++","++ DATA INTERCEPTED ++","++ DECRYPTING ORDER ++","++ ORDER: SIGMA-9 ++","++ COGITATOR ACCESS ++","++ BY HIS WILL ++","++ CLASSIFIED MATERIAL ++","++ MIND CLEANSED ++","++ CODEX SECURED ++"],
      suffixes:["++ THE EMPEROR PROTECTS ++","++ AUTHORIZATION VERIFIED ++","++ PURGE COMPLETE ++","++ FAITH REMAINS ++","++ THOUGHT FOR THE DAY ++","++ HERESY PURGED ++","++ OATH UPHELD ++","++ FAITH IS ARMOR ++","++ EXAMINATION COMPLETE ++"]
    },
    militarum: {
      prefixes:["++ IMPERIAL SIGNAL ++","++ HIGH COMMAND ORDER ++","++ ORDERS INCOMING ++","++ TACTICAL FEED ++","++ REGIMENTAL DATA ++","++ COMMAND OVERRIDE ++","++ BATTLELINE UPLINK ++","++ ENGAGEMENT ACTIVE ++","++ OPERATIONAL BRIEF ++"],
      suffixes:["++ GLORY TO THE GUARD ++","++ VICTORY IS ASSURED ++","++ CADIA STANDS ++","++ DUTY FULFILLED ++","++ NO SACRIFICE TOO GREAT ++","++ PERIMETER SECURED ++","++ FOR THE EMPEROR ++","++ STATUS: GREEN ++","++ STRATEGIC DIRECTIVE ++"]
    },
    chaos_undivided: {
      prefixes:["++ WARP STIRRING ++","++ TRANSMISSION CORRUPTED ++","++ HERESY INBOUND ++","++ WARP SIGNATURE FOUND ++","++ SACRIFICE ACCEPTED ++","++ WARP ENERGY RISING ++","++ ORDER BREAKS ++","++ FLESH TURNS ++","++ ASCENSION IMMINENT ++"],
      suffixes:["++ GLORY TO CHAOS ++","++ DARK GODS SMILE ++","++ THE EYE OPENS ++","++ ASCEND AND BURN ++","++ ALL HAIL THE DARK GODS ++","++ REALSPACE BLEEDS ++","++ STARS ARE WRONG ++","++ VOID WITHIN ++","++ ETERNAL CHANGE ++"]
    },
    khorne: {
      prefixes:["++ BLOOD ALERT ++","++ SKULL COUNT RISING ++","++ RAGE TRANSMISSION ++","++ COMBAT UPLINK ++","++ SLAUGHTER INITIATED ++","++ VIOLENCE MAXIMUM ++","++ NO PEACE ONLY WAR ++","++ RIP THEIR HEADS ++","++ DOMINATE THROUGH BLOOD ++"],
      suffixes:["++ BLOOD FOR THE BLOOD GOD ++","++ SKULLS FOR THE THRONE ++","++ RIP AND TEAR ++","++ ALL MUST BLEED ++","++ DEATH WITHOUT END ++","++ STRIKE WITHOUT MERCY ++","++ AXE ONLINE ++","++ RED FLOWS ++","++ KILL. MAIM. BURN. ++"]
    },
    nurgle: {
      prefixes:["++ BLOAT SIGNAL ++","++ DECAY INITIATED ++","++ DISEASE VECTOR ACTIVE ++","++ PLAGUE SEED SENT ++","++ SPOREFIELD DEPLOYED ++","++ VIRUSCODE ENGAGED ++","++ ALL IS ROT ++","++ MUCOUS FLOW ++","++ FOULNESS RISES ++"],
      suffixes:["++ PRAISE GRANDPA NURGLE ++","++ FILTH TRANSMITTED ++","++ ROTTEN JOY ++","++ CONTAGION SPREADS ++","++ FLIES REJOICE ++","++ FESTERING COMPLETE ++","++ BLESSINGS OF ROT ++","++ FLESH SAGS ++","++ CORRUPTION GLORIOUS ++"]
    },
    tzeentch: {
      prefixes:["++ KNOWLEDGE UNFOLDS ++","++ SCHEME RUNNING ++","++ DATA TWISTED ++","++ WARP-TEXT INCOMING ++","++ INVERSION ACTIVE ++","++ DESTINY WRITTEN ++","++ NOTHING IS AS IT SEEMS ++","++ PATTERNS SHIFT ++","++ BURN THE SCRIPT ++"],
      suffixes:["++ ALL IS CHANGE ++","++ PLAN: PHASE 7 ++","++ EYE OPENS ++","++ BIRD OF FATE SMILES ++","++ THOUGHT MUTATED ++","++ CYCLE CONTINUES ++","++ OBSERVE THE CHANGE ++","++ REWRITE EVERYTHING ++","++ JUST AS PLANNED ++"]
    },
    slaanesh: {
      prefixes:["++ ECSTASY PULSE ++","++ SENSORY OVERLOAD ++","++ LUXURY CHANNEL OPEN ++","++ VELVET SIGNAL ++","++ DESIRE BREACH ++","++ TOUCH THE DIVINE ++","++ TASTE THE PAIN ++","++ LUSTWAVE TRANSMITTED ++","++ EXCESS COMPLETE ++"],
      suffixes:["++ FEED THE HUNGER ++","++ THE PERFECT MOMENT ++","++ PAIN IS PLEASURE ++","++ EXCESS IS TRUTH ++","++ PLEASURE SATURATED ++","++ UNHOLY HARMONY ++","++ FEEL EVERYTHING ++","++ TEMPTATION SPIKE ++","++ PERFECTION IS BLISS ++"]
    }
  };

  // ===== UI =====
  const el = {
    faction: document.getElementById("faction"),

    msgColor: document.getElementById("msgColor"),
    msgQuick: document.getElementById("msgQuick"),
    msgSize: document.getElementById("msgSize"),

    psColor: document.getElementById("psColor"),
    psQuick: document.getElementById("psQuick"),
    psSize: document.getElementById("psSize"),

    randomFillers: document.getElementById("randomFillers"),
    manualPrefix: document.getElementById("manualPrefix"),
    manualSuffix: document.getElementById("manualSuffix"),
    previewPrefix: document.getElementById("previewPrefix"),
    previewSuffix: document.getElementById("previewSuffix"),

    text: document.getElementById("text"),
    clearText: document.getElementById("clearText"),

    useDefaultPing: document.getElementById("useDefaultPing"),
    useDefaultMsg: document.getElementById("useDefaultMsg"),
    defaultPingUrl: document.getElementById("defaultPingUrl"),
    defaultMsgUrl: document.getElementById("defaultMsgUrl"),
    factionPingUrl: document.getElementById("factionPingUrl"),
    factionMsgUrl: document.getElementById("factionMsgUrl"),
    saveAudio: document.getElementById("saveAudio"),
    ping: document.getElementById("ping"),

    send: document.getElementById("send"),
    clearScreen: document.getElementById("clearScreen"),
    status: document.getElementById("status"),
  };

  function setStatus(s){
    el.status.textContent = s;
  }

  // ===== Helpers =====
  function clampIndex(idx, max){
    const n = Number(idx);
    if(!Number.isFinite(n)) return 1;
    return Math.max(1, Math.min(max, Math.floor(n)));
  }

  function pickFrom(arr, idx1){
    const i = clampIndex(idx1, arr.length) - 1;
    return arr[i] ?? "";
  }

  function getFactionFillers(faction){
    return FILLERS[faction] || FILLERS.mechanicus;
  }

  function rand1to(n){
    return 1 + Math.floor(Math.random()*n);
  }

  function updateManualEnabled(){
    const on = !el.randomFillers.checked;
    el.manualPrefix.disabled = !on;
    el.manualSuffix.disabled = !on;
  }

  function updateAudioEnabled(){
    el.factionPingUrl.disabled = el.useDefaultPing.checked;
    el.factionMsgUrl.disabled  = el.useDefaultMsg.checked;
  }

  function updatePreviews(){
    const faction = el.faction.value;
    const f = getFactionFillers(faction);

    let pIdx = Number(el.manualPrefix.value || 1);
    let sIdx = Number(el.manualSuffix.value || 1);

    if(el.randomFillers.checked){
      pIdx = rand1to(f.prefixes.length);
      sIdx = rand1to(f.suffixes.length);
    }else{
      pIdx = clampIndex(pIdx, f.prefixes.length);
      sIdx = clampIndex(sIdx, f.suffixes.length);
    }

    el.previewPrefix.textContent = pickFrom(f.prefixes, pIdx) || "‚Äî";
    el.previewSuffix.textContent = pickFrom(f.suffixes, sIdx) || "‚Äî";
  }

  function wireQuickColors(containerEl, targetInput){
    containerEl.querySelectorAll(".chip").forEach(chip=>{
      chip.addEventListener("click", ()=>{
        const c = chip.getAttribute("data-color");
        targetInput.value = c;
      });
    });
  }

  // ===== Persist (localStorage) =====
  const LS_KEY = "wh40k_dataslate_gm_state_v2";
  function saveState(){
    const state = {
      faction: el.faction.value,
      msgColor: el.msgColor.value,
      msgSize: el.msgSize.value,
      psColor: el.psColor.value,
      psSize: el.psSize.value,
      randomFillers: el.randomFillers.checked,
      manualPrefix: el.manualPrefix.value,
      manualSuffix: el.manualSuffix.value,
      text: el.text.value,
      useDefaultPing: el.useDefaultPing.checked,
      useDefaultMsg: el.useDefaultMsg.checked,
      defaultPingUrl: el.defaultPingUrl.value,
      defaultMsgUrl: el.defaultMsgUrl.value,
      factionPingUrl: el.factionPingUrl.value,
      factionMsgUrl: el.factionMsgUrl.value
    };
    localStorage.setItem(LS_KEY, JSON.stringify(state));
  }
  function loadState(){
    try{
      const raw = localStorage.getItem(LS_KEY);
      if(!raw) return;
      const s = JSON.parse(raw);

      if(s.faction) el.faction.value = s.faction;
      if(s.msgColor) el.msgColor.value = s.msgColor;
      if(s.msgSize) el.msgSize.value = s.msgSize;
      if(s.psColor) el.psColor.value = s.psColor;
      if(s.psSize) el.psSize.value = s.psSize;

      if(typeof s.randomFillers === "boolean") el.randomFillers.checked = s.randomFillers;
      if(s.manualPrefix) el.manualPrefix.value = s.manualPrefix;
      if(s.manualSuffix) el.manualSuffix.value = s.manualSuffix;
      if(typeof s.text === "string") el.text.value = s.text;

      if(typeof s.useDefaultPing === "boolean") el.useDefaultPing.checked = s.useDefaultPing;
      if(typeof s.useDefaultMsg === "boolean") el.useDefaultMsg.checked = s.useDefaultMsg;
      if(s.defaultPingUrl) el.defaultPingUrl.value = s.defaultPingUrl;
      if(s.defaultMsgUrl) el.defaultMsgUrl.value = s.defaultMsgUrl;
      if(typeof s.factionPingUrl === "string") el.factionPingUrl.value = s.factionPingUrl;
      if(typeof s.factionMsgUrl === "string") el.factionMsgUrl.value = s.factionMsgUrl;
    }catch(e){}
  }

  // ===== Firestore: config audio =====
  async function ensureConfigDoc(){
    const snap = await getDoc(configRef);
    if(!snap.exists()){
      await setDoc(configRef, {
        defaults: {
          pingUrl: el.defaultPingUrl.value || "assets/audio/global/Ping.mp3",
          msgUrl:  el.defaultMsgUrl.value  || "assets/audio/global/Message.mp3",
        },
        perFaction: {}
      }, {merge:true});
    }
  }

  async function saveAudioConfig(){
    await ensureConfigDoc();

    const faction = el.faction.value;
    const defaults = {
      pingUrl: el.defaultPingUrl.value.trim() || "assets/audio/global/Ping.mp3",
      msgUrl:  el.defaultMsgUrl.value.trim()  || "assets/audio/global/Message.mp3",
    };

    const perFaction = {};
    perFaction[faction] = {
      pingUrl: el.useDefaultPing.checked ? "" : (el.factionPingUrl.value.trim() || ""),
      msgUrl:  el.useDefaultMsg.checked  ? "" : (el.factionMsgUrl.value.trim() || "")
    };

    await setDoc(configRef, { defaults, perFaction }, { merge:true });
    setStatus(`‚úÖ Zapisano audio w dataslate/config (defaults + ${faction}).`);
  }

  // ===== Build payload for message =====
  function buildStylePayload(){
    // wiadomo≈õƒá: msgFontSize
    const msgPx = Number(el.msgSize.value || 28);
    const msgFontSize = `${Math.max(12, Math.min(80, Math.floor(msgPx)))}px`;

    // prefix/suffix: wsp√≥lne
    const psPx = Number(el.psSize.value || 14);
    const psFontSize = `${Math.max(10, Math.min(60, Math.floor(psPx)))}px`;

    // Kolory
    const msgColor = (el.msgColor.value || "#00ff66").trim();
    const psColor  = (el.psColor.value  || "rgba(255,255,255,.88)").trim();

    return {
      color: msgColor,
      msgFontSize: msgFontSize,
      prefixFontSize: psFontSize,
      suffixFontSize: psFontSize,
      prefixColor: psColor,
      suffixColor: psColor
    };
  }

  function pickPrefixSuffixForSend(){
    const faction = el.faction.value;
    const f = getFactionFillers(faction);

    if(el.randomFillers.checked){
      return {
        prefixIndex: rand1to(f.prefixes.length),
        suffixIndex: rand1to(f.suffixes.length)
      };
    }
    return {
      prefixIndex: clampIndex(el.manualPrefix.value, f.prefixes.length),
      suffixIndex: clampIndex(el.manualSuffix.value, f.suffixes.length)
    };
  }

  // ===== Send actions =====
  async function sendMessage(){
    const faction = el.faction.value;
    const text = el.text.value ?? "";

    const style = buildStylePayload();
    const pick = pickPrefixSuffixForSend();

    // audio urls w payloadzie: odczyta Infoczytnik (z config i/lub z payloadu),
    // zostawiamy prosto: wysy≈Çamy tylko je≈õli chcesz wymusiƒá per wiadomo≈õƒá
    const payload = {
      type: "message",
      faction,
      text,
      ...pick,
      ...style,
      nonce: `${Date.now()}-${Math.random().toString().slice(2)}`,
      sentAt: serverTimestamp()
    };

    await setDoc(currentRef, payload, { merge:true });
    setStatus(`üì® Wys≈Çano wiadomo≈õƒá (${faction}).`);
    updatePreviews(); // po wysy≈Çce (szczeg√≥lnie gdy losowanie) od≈õwie≈º podglƒÖd
  }

  async function clearScreen(){
    const faction = el.faction.value;
    const style = buildStylePayload();

    await setDoc(currentRef, {
      type: "clear",
      faction,
      ...style,
      nonce: `${Date.now()}-${Math.random().toString().slice(2)}`,
      sentAt: serverTimestamp()
    }, { merge:true });

    setStatus("üßπ Wys≈Çano: wyczy≈õƒá ekran (Infoczytnik).");
  }

  async function doPing(){
    const faction = el.faction.value;
    const style = buildStylePayload();

    // Ping URL: bierzemy domy≈õlny lub frakcyjny zale≈ºnie od checkboxa i pola
    const pingUrl = el.useDefaultPing.checked ? (el.defaultPingUrl.value.trim() || "assets/audio/global/Ping.mp3")
                                              : (el.factionPingUrl.value.trim() || (el.defaultPingUrl.value.trim() || "assets/audio/global/Ping.mp3"));

    await setDoc(currentRef, {
      type: "ping",
      faction,
      pingUrl,
      ...style,
      nonce: `${Date.now()}-${Math.random().toString().slice(2)}`,
      sentAt: serverTimestamp()
    }, { merge:true });

    setStatus(`üì° Ping wys≈Çany (${faction}).`);
  }

  // ===== Wiring =====
  wireQuickColors(el.msgQuick, el.msgColor);
  wireQuickColors(el.psQuick, el.psColor);

  el.randomFillers.addEventListener("change", ()=>{ updateManualEnabled(); updatePreviews(); saveState(); });
  el.manualPrefix.addEventListener("input", ()=>{ updatePreviews(); saveState(); });
  el.manualSuffix.addEventListener("input", ()=>{ updatePreviews(); saveState(); });
  el.faction.addEventListener("change", ()=>{ updatePreviews(); saveState(); });

  el.msgColor.addEventListener("input", saveState);
  el.msgSize.addEventListener("input", saveState);
  el.psColor.addEventListener("input", saveState);
  el.psSize.addEventListener("input", saveState);

  el.useDefaultPing.addEventListener("change", ()=>{ updateAudioEnabled(); saveState(); });
  el.useDefaultMsg.addEventListener("change", ()=>{ updateAudioEnabled(); saveState(); });

  el.defaultPingUrl.addEventListener("input", saveState);
  el.defaultMsgUrl.addEventListener("input", saveState);
  el.factionPingUrl.addEventListener("input", saveState);
  el.factionMsgUrl.addEventListener("input", saveState);

  el.saveAudio.addEventListener("click", async ()=>{
    try{ await saveAudioConfig(); }
    catch(e){ setStatus("‚ùå B≈ÇƒÖd zapisu audio: " + (e?.message || e)); }
  });

  el.ping.addEventListener("click", async ()=>{
    try{ await doPing(); }
    catch(e){ setStatus("‚ùå B≈ÇƒÖd Ping: " + (e?.message || e)); }
  });

  el.send.addEventListener("click", async ()=>{
    try{ await sendMessage(); }
    catch(e){ setStatus("‚ùå B≈ÇƒÖd wysy≈Çki: " + (e?.message || e)); }
  });

  el.clearScreen.addEventListener("click", async ()=>{
    try{ await clearScreen(); }
    catch(e){ setStatus("‚ùå B≈ÇƒÖd czyszczenia: " + (e?.message || e)); }
  });

  el.clearText.addEventListener("click", ()=>{
    el.text.value = "";
    saveState();
    setStatus("üßΩ Wyczy≈õci≈Çe≈õ pole tekstowe (lokalnie w GM).");
  });

  // init
  loadState();
  updateManualEnabled();
  updateAudioEnabled();
  updatePreviews();
  setStatus("Gotowe.");
</script>
</body>
</html>
